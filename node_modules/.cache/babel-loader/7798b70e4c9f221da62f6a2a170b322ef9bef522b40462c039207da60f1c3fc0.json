{"ast":null,"code":"'use client';\n\nimport { useRef, useState, useCallback } from 'react';\nfunction useInViewport() {\n  const observer = useRef(null);\n  const [inViewport, setInViewport] = useState(false);\n  const ref = useCallback(node => {\n    if (typeof IntersectionObserver !== \"undefined\") {\n      if (node && !observer.current) {\n        observer.current = new IntersectionObserver(entries => {\n          const lastEntry = entries[entries.length - 1];\n          setInViewport(lastEntry.isIntersecting);\n        });\n      } else {\n        observer.current?.disconnect();\n      }\n      if (node) {\n        observer.current?.observe(node);\n      } else {\n        setInViewport(false);\n      }\n    }\n  }, []);\n  return {\n    ref,\n    inViewport\n  };\n}\nexport { useInViewport };","map":{"version":3,"names":["useInViewport","observer","useRef","inViewport","setInViewport","useState","ref","useCallback","node","IntersectionObserver","current","entries","lastEntry","length","isIntersecting","disconnect","observe"],"sources":["C:\\Users\\fapfl\\my-react-app\\node_modules\\@mantine\\hooks\\src\\use-in-viewport\\use-in-viewport.ts"],"sourcesContent":["import { useCallback, useRef, useState } from 'react';\n\nexport interface UseInViewportReturnValue<T extends HTMLElement = any> {\n  inViewport: boolean;\n  ref: React.RefCallback<T | null>;\n}\n\nexport function useInViewport<T extends HTMLElement = any>(): UseInViewportReturnValue<T> {\n  const observer = useRef<IntersectionObserver | null>(null);\n  const [inViewport, setInViewport] = useState(false);\n\n  const ref: React.RefCallback<T | null> = useCallback((node) => {\n    if (typeof IntersectionObserver !== 'undefined') {\n      if (node && !observer.current) {\n        observer.current = new IntersectionObserver((entries) => {\n          // Entries might be batched (e.g. when scrolling very fast), so we need to use the last entry to get the most recent state\n          const lastEntry = entries[entries.length - 1];\n          setInViewport(lastEntry.isIntersecting);\n        });\n      } else {\n        observer.current?.disconnect();\n      }\n\n      if (node) {\n        observer.current?.observe(node);\n      } else {\n        setInViewport(false);\n      }\n    }\n  }, []);\n\n  return { ref, inViewport };\n}\n"],"mappings":";;;AAOO,SAASA,cAAA,EAA0E;EACxF,MAAMC,QAAA,GAAWC,MAAA,CAAoC,IAAI;EACzD,MAAM,CAACC,UAAA,EAAYC,aAAa,IAAIC,QAAA,CAAS,KAAK;EAElD,MAAMC,GAAA,GAAmCC,WAAA,CAAaC,IAAA,IAAS;IAC7D,IAAI,OAAOC,oBAAA,KAAyB,aAAa;MAC/C,IAAID,IAAA,IAAQ,CAACP,QAAA,CAASS,OAAA,EAAS;QAC7BT,QAAA,CAASS,OAAA,GAAU,IAAID,oBAAA,CAAsBE,OAAA,IAAY;UAEvD,MAAMC,SAAA,GAAYD,OAAA,CAAQA,OAAA,CAAQE,MAAA,GAAS,CAAC;UAC5CT,aAAA,CAAcQ,SAAA,CAAUE,cAAc;QACxC,CAAC;MACH,OAAO;QACLb,QAAA,CAASS,OAAA,EAASK,UAAA,EAAW;MAC/B;MAEA,IAAIP,IAAA,EAAM;QACRP,QAAA,CAASS,OAAA,EAASM,OAAA,CAAQR,IAAI;MAChC,OAAO;QACLJ,aAAA,CAAc,KAAK;MACrB;IACF;EACF,GAAG,EAAE;EAEL,OAAO;IAAEE,GAAA;IAAKH;EAAA,CAAW;AAC3B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}