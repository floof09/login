{"ast":null,"code":"'use client';\n\nimport { jsxs, jsx } from 'react/jsx-runtime';\nimport { useRef } from 'react';\nimport cx from 'clsx';\nimport { NumericFormat } from 'react-number-format';\nimport { useUncontrolled, clamp, assignRef, useMergedRef } from '@mantine/hooks';\nimport '../../core/utils/units-converters/rem.mjs';\nimport { noop } from '../../core/utils/noop/noop.mjs';\nimport { getSize } from '../../core/utils/get-size/get-size.mjs';\nimport { createVarsResolver } from '../../core/styles-api/create-vars-resolver/create-vars-resolver.mjs';\nimport { useResolvedStylesApi } from '../../core/styles-api/use-resolved-styles-api/use-resolved-styles-api.mjs';\nimport { useStyles } from '../../core/styles-api/use-styles/use-styles.mjs';\nimport '../../core/MantineProvider/Mantine.context.mjs';\nimport '../../core/MantineProvider/default-theme.mjs';\nimport '../../core/MantineProvider/MantineProvider.mjs';\nimport '../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport { useProps } from '../../core/MantineProvider/use-props/use-props.mjs';\nimport '../../core/MantineProvider/MantineCssVariables/MantineCssVariables.mjs';\nimport '../../core/Box/Box.mjs';\nimport { factory } from '../../core/factory/factory.mjs';\nimport '../../core/DirectionProvider/DirectionProvider.mjs';\nimport { InputBase } from '../InputBase/InputBase.mjs';\nimport { UnstyledButton } from '../UnstyledButton/UnstyledButton.mjs';\nimport classes from './NumberInput.module.css.mjs';\nimport { NumberInputChevron } from './NumberInputChevron.mjs';\nconst leadingDecimalZeroPattern = /^(0\\.0*|-0(\\.0*)?)$/;\nconst leadingZerosPattern = /^-?0\\d+(\\.\\d+)?\\.?$/;\nconst trailingZerosPattern = /\\.\\d*0$/;\nconst trailingDecimalSeparatorPattern = /^-?\\d+\\.$/;\nfunction isNumberString(value) {\n  return typeof value === \"string\" && value !== \"\" && !Number.isNaN(Number(value));\n}\nfunction canIncrement(value) {\n  if (typeof value === \"number\") {\n    return value < Number.MAX_SAFE_INTEGER;\n  }\n  return value === \"\" || isNumberString(value) && Number(value) < Number.MAX_SAFE_INTEGER;\n}\nfunction getDecimalPlaces(inputValue) {\n  return inputValue.toString().replace(\".\", \"\").length;\n}\nfunction isValidNumber(floatValue, value) {\n  return (typeof floatValue === \"number\" ? floatValue < Number.MAX_SAFE_INTEGER : !Number.isNaN(Number(floatValue))) && !Number.isNaN(floatValue) && getDecimalPlaces(value) < 14 && value !== \"\";\n}\nfunction isInRange(value, min, max) {\n  if (value === void 0) {\n    return true;\n  }\n  const minValid = min === void 0 || value >= min;\n  const maxValid = max === void 0 || value <= max;\n  return minValid && maxValid;\n}\nconst defaultProps = {\n  step: 1,\n  clampBehavior: \"blur\",\n  allowDecimal: true,\n  allowNegative: true,\n  withKeyboardEvents: true,\n  allowLeadingZeros: true,\n  trimLeadingZeroesOnBlur: true,\n  startValue: 0,\n  allowedDecimalSeparators: [\".\", \",\"]\n};\nconst varsResolver = createVarsResolver((_, {\n  size\n}) => ({\n  controls: {\n    \"--ni-chevron-size\": getSize(size, \"ni-chevron-size\")\n  }\n}));\nfunction clampAndSanitizeInput(sanitizedValue, max, min) {\n  const stringValue = sanitizedValue.toString();\n  const hasTrailingDecimalSeparator = trailingDecimalSeparatorPattern.test(stringValue);\n  const replaced = stringValue.replace(/^0+(?=\\d)/, \"\");\n  const parsedValue = parseFloat(replaced);\n  if (Number.isNaN(parsedValue)) {\n    return replaced;\n  }\n  if (parsedValue > Number.MAX_SAFE_INTEGER) {\n    return max !== void 0 ? max : replaced;\n  }\n  const clamped = clamp(parsedValue, min, max);\n  if (hasTrailingDecimalSeparator) {\n    const clampedString = clamped.toString().replace(/^0+(?=\\d)/, \"\");\n    return `${clampedString}.`;\n  }\n  return clamped;\n}\nconst NumberInput = factory((_props, ref) => {\n  const props = useProps(\"NumberInput\", defaultProps, _props);\n  const {\n    className,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    onChange,\n    onValueChange,\n    value,\n    defaultValue,\n    max,\n    min,\n    step,\n    hideControls,\n    rightSection,\n    isAllowed,\n    clampBehavior,\n    onBlur,\n    allowDecimal,\n    decimalScale,\n    onKeyDown,\n    onKeyDownCapture,\n    handlersRef,\n    startValue,\n    disabled,\n    rightSectionPointerEvents,\n    allowNegative,\n    readOnly,\n    size,\n    rightSectionWidth,\n    stepHoldInterval,\n    stepHoldDelay,\n    allowLeadingZeros,\n    withKeyboardEvents,\n    trimLeadingZeroesOnBlur,\n    allowedDecimalSeparators,\n    attributes,\n    ...others\n  } = props;\n  const getStyles = useStyles({\n    name: \"NumberInput\",\n    classes,\n    props,\n    classNames,\n    styles,\n    unstyled,\n    attributes,\n    vars,\n    varsResolver\n  });\n  const {\n    resolvedClassNames,\n    resolvedStyles\n  } = useResolvedStylesApi({\n    classNames,\n    styles,\n    props\n  });\n  const [_value, setValue] = useUncontrolled({\n    value,\n    defaultValue,\n    finalValue: \"\",\n    onChange\n  });\n  const shouldUseStepInterval = stepHoldDelay !== void 0 && stepHoldInterval !== void 0;\n  const inputRef = useRef(null);\n  const onStepTimeoutRef = useRef(null);\n  const stepCountRef = useRef(0);\n  const handleValueChange = (payload, event) => {\n    if (event.source === \"event\") {\n      setValue(isValidNumber(payload.floatValue, payload.value) && !leadingDecimalZeroPattern.test(payload.value) && !(allowLeadingZeros ? leadingZerosPattern.test(payload.value) : false) && !trailingZerosPattern.test(payload.value) && !trailingDecimalSeparatorPattern.test(payload.value) ? payload.floatValue : payload.value);\n    }\n    onValueChange?.(payload, event);\n  };\n  const getDecimalPlaces2 = inputValue => {\n    const match = String(inputValue).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n    if (!match) {\n      return 0;\n    }\n    return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? +match[2] : 0));\n  };\n  const adjustCursor = position => {\n    if (inputRef.current && typeof position !== \"undefined\") {\n      inputRef.current.setSelectionRange(position, position);\n    }\n  };\n  const incrementRef = useRef(noop);\n  incrementRef.current = () => {\n    if (!canIncrement(_value)) {\n      return;\n    }\n    let val;\n    const currentValuePrecision = getDecimalPlaces2(_value);\n    const stepPrecision = getDecimalPlaces2(step);\n    const maxPrecision = Math.max(currentValuePrecision, stepPrecision);\n    const factor = 10 ** maxPrecision;\n    if (!isNumberString(_value) && (typeof _value !== \"number\" || Number.isNaN(_value))) {\n      val = clamp(startValue, min, max);\n    } else if (max !== void 0) {\n      const incrementedValue = (Math.round(Number(_value) * factor) + Math.round(step * factor)) / factor;\n      val = incrementedValue <= max ? incrementedValue : max;\n    } else {\n      val = (Math.round(Number(_value) * factor) + Math.round(step * factor)) / factor;\n    }\n    const formattedValue = val.toFixed(maxPrecision);\n    setValue(parseFloat(formattedValue));\n    onValueChange?.({\n      floatValue: parseFloat(formattedValue),\n      formattedValue,\n      value: formattedValue\n    }, {\n      source: \"increment\"\n    });\n    setTimeout(() => adjustCursor(inputRef.current?.value.length), 0);\n  };\n  const decrementRef = useRef(noop);\n  decrementRef.current = () => {\n    if (!canIncrement(_value)) {\n      return;\n    }\n    let val;\n    const minValue = min !== void 0 ? min : !allowNegative ? 0 : Number.MIN_SAFE_INTEGER;\n    const currentValuePrecision = getDecimalPlaces2(_value);\n    const stepPrecision = getDecimalPlaces2(step);\n    const maxPrecision = Math.max(currentValuePrecision, stepPrecision);\n    const factor = 10 ** maxPrecision;\n    if (!isNumberString(_value) && typeof _value !== \"number\" || Number.isNaN(_value)) {\n      val = clamp(startValue, minValue, max);\n    } else {\n      const decrementedValue = (Math.round(Number(_value) * factor) - Math.round(step * factor)) / factor;\n      val = minValue !== void 0 && decrementedValue < minValue ? minValue : decrementedValue;\n    }\n    const formattedValue = val.toFixed(maxPrecision);\n    setValue(parseFloat(formattedValue));\n    onValueChange?.({\n      floatValue: parseFloat(formattedValue),\n      formattedValue,\n      value: formattedValue\n    }, {\n      source: \"decrement\"\n    });\n    setTimeout(() => adjustCursor(inputRef.current?.value.length), 0);\n  };\n  const handleKeyDown = event => {\n    onKeyDown?.(event);\n    if (readOnly || !withKeyboardEvents) {\n      return;\n    }\n    if (event.key === \"ArrowUp\") {\n      event.preventDefault();\n      incrementRef.current?.();\n    }\n    if (event.key === \"ArrowDown\") {\n      event.preventDefault();\n      decrementRef.current?.();\n    }\n  };\n  const handleKeyDownCapture = event => {\n    onKeyDownCapture?.(event);\n    if (event.key === \"Backspace\") {\n      const input = inputRef.current;\n      if (input && input.selectionStart === 0 && input.selectionStart === input.selectionEnd) {\n        event.preventDefault();\n        window.setTimeout(() => adjustCursor(0), 0);\n      }\n    }\n  };\n  const handleBlur = event => {\n    let sanitizedValue = _value;\n    if (clampBehavior === \"blur\" && typeof sanitizedValue === \"number\") {\n      sanitizedValue = clamp(sanitizedValue, min, max);\n    }\n    if (trimLeadingZeroesOnBlur && typeof sanitizedValue === \"string\" && getDecimalPlaces2(sanitizedValue) < 15) {\n      sanitizedValue = clampAndSanitizeInput(sanitizedValue, max, min);\n    }\n    if (_value !== sanitizedValue) {\n      setValue(sanitizedValue);\n    }\n    onBlur?.(event);\n  };\n  assignRef(handlersRef, {\n    increment: incrementRef.current,\n    decrement: decrementRef.current\n  });\n  const onStepHandleChange = isIncrement => {\n    if (isIncrement) {\n      incrementRef.current?.();\n    } else {\n      decrementRef.current?.();\n    }\n    stepCountRef.current += 1;\n  };\n  const onStepLoop = isIncrement => {\n    onStepHandleChange(isIncrement);\n    if (shouldUseStepInterval) {\n      const interval = typeof stepHoldInterval === \"number\" ? stepHoldInterval : stepHoldInterval(stepCountRef.current);\n      onStepTimeoutRef.current = window.setTimeout(() => onStepLoop(isIncrement), interval);\n    }\n  };\n  const onStep = (event, isIncrement) => {\n    event.preventDefault();\n    inputRef.current?.focus();\n    onStepHandleChange(isIncrement);\n    if (shouldUseStepInterval) {\n      onStepTimeoutRef.current = window.setTimeout(() => onStepLoop(isIncrement), stepHoldDelay);\n    }\n  };\n  const onStepDone = () => {\n    if (onStepTimeoutRef.current) {\n      window.clearTimeout(onStepTimeoutRef.current);\n    }\n    onStepTimeoutRef.current = null;\n    stepCountRef.current = 0;\n  };\n  const controls = /* @__PURE__ */jsxs(\"div\", {\n    ...getStyles(\"controls\"),\n    children: [/* @__PURE__ */jsx(UnstyledButton, {\n      ...getStyles(\"control\"),\n      tabIndex: -1,\n      \"aria-hidden\": true,\n      disabled: disabled || typeof _value === \"number\" && max !== void 0 && _value >= max,\n      mod: {\n        direction: \"up\"\n      },\n      onMouseDown: event => event.preventDefault(),\n      onPointerDown: event => {\n        onStep(event, true);\n      },\n      onPointerUp: onStepDone,\n      onPointerLeave: onStepDone,\n      children: /* @__PURE__ */jsx(NumberInputChevron, {\n        direction: \"up\"\n      })\n    }), /* @__PURE__ */jsx(UnstyledButton, {\n      ...getStyles(\"control\"),\n      tabIndex: -1,\n      \"aria-hidden\": true,\n      disabled: disabled || typeof _value === \"number\" && min !== void 0 && _value <= min,\n      mod: {\n        direction: \"down\"\n      },\n      onMouseDown: event => event.preventDefault(),\n      onPointerDown: event => {\n        onStep(event, false);\n      },\n      onPointerUp: onStepDone,\n      onPointerLeave: onStepDone,\n      children: /* @__PURE__ */jsx(NumberInputChevron, {\n        direction: \"down\"\n      })\n    })]\n  });\n  return /* @__PURE__ */jsx(InputBase, {\n    component: NumericFormat,\n    allowNegative,\n    className: cx(classes.root, className),\n    size,\n    inputMode: \"decimal\",\n    ...others,\n    readOnly,\n    disabled,\n    value: _value,\n    getInputRef: useMergedRef(ref, inputRef),\n    onValueChange: handleValueChange,\n    rightSection: hideControls || readOnly || !canIncrement(_value) ? rightSection : rightSection || controls,\n    classNames: resolvedClassNames,\n    styles: resolvedStyles,\n    unstyled,\n    __staticSelector: \"NumberInput\",\n    decimalScale: allowDecimal ? decimalScale : 0,\n    onKeyDown: handleKeyDown,\n    onKeyDownCapture: handleKeyDownCapture,\n    rightSectionPointerEvents: rightSectionPointerEvents ?? (disabled ? \"none\" : void 0),\n    rightSectionWidth: rightSectionWidth ?? `var(--ni-right-section-width-${size || \"sm\"})`,\n    allowLeadingZeros,\n    allowedDecimalSeparators,\n    onBlur: handleBlur,\n    attributes,\n    isAllowed: val => {\n      if (clampBehavior === \"strict\") {\n        if (isAllowed) {\n          return isAllowed(val) && isInRange(val.floatValue, min, max);\n        }\n        return isInRange(val.floatValue, min, max);\n      }\n      return isAllowed ? isAllowed(val) : true;\n    }\n  });\n});\nNumberInput.classes = {\n  ...InputBase.classes,\n  ...classes\n};\nNumberInput.displayName = \"@mantine/core/NumberInput\";\nexport { NumberInput };","map":{"version":3,"names":["leadingDecimalZeroPattern","leadingZerosPattern","trailingZerosPattern","trailingDecimalSeparatorPattern","isNumberString","value","Number","isNaN","canIncrement","MAX_SAFE_INTEGER","getDecimalPlaces","inputValue","toString","replace","length","isValidNumber","floatValue","isInRange","min","max","minValid","maxValid","defaultProps","step","clampBehavior","allowDecimal","allowNegative","withKeyboardEvents","allowLeadingZeros","trimLeadingZeroesOnBlur","startValue","allowedDecimalSeparators","varsResolver","createVarsResolver","_","size","controls","getSize","clampAndSanitizeInput","sanitizedValue","stringValue","hasTrailingDecimalSeparator","test","replaced","parsedValue","parseFloat","clamped","clamp","clampedString","NumberInput","factory","_props","ref","props","useProps","className","classNames","styles","unstyled","vars","onChange","onValueChange","defaultValue","hideControls","rightSection","isAllowed","onBlur","decimalScale","onKeyDown","onKeyDownCapture","handlersRef","disabled","rightSectionPointerEvents","readOnly","rightSectionWidth","stepHoldInterval","stepHoldDelay","attributes","others","getStyles","useStyles","name","classes","resolvedClassNames","resolvedStyles","useResolvedStylesApi","_value","setValue","useUncontrolled","finalValue","shouldUseStepInterval","inputRef","useRef","onStepTimeoutRef","stepCountRef","handleValueChange","payload","event","source","getDecimalPlaces2","match","String","Math","adjustCursor","position","current","setSelectionRange","incrementRef","noop","val","currentValuePrecision","stepPrecision","maxPrecision","factor","incrementedValue","round","formattedValue","toFixed","setTimeout","decrementRef","minValue","MIN_SAFE_INTEGER","decrementedValue","handleKeyDown","key","preventDefault","handleKeyDownCapture","input","selectionStart","selectionEnd","window","handleBlur","assignRef","increment","decrement","onStepHandleChange","isIncrement","onStepLoop","interval","onStep","focus","onStepDone","clearTimeout","jsxs","children","jsx","UnstyledButton","tabIndex","mod","direction","onMouseDown","onPointerDown","onPointerUp","onPointerLeave","NumberInputChevron","InputBase","component","NumericFormat","cx","root","inputMode","getInputRef","useMergedRef","__staticSelector","displayName"],"sources":["C:\\Users\\fapfl\\my-react-app\\node_modules\\@mantine\\core\\src\\components\\NumberInput\\NumberInput.tsx"],"sourcesContent":["import React, { useRef } from 'react';\nimport cx from 'clsx';\nimport { NumberFormatValues, NumericFormat, OnValueChange } from 'react-number-format';\nimport { assignRef, clamp, useMergedRef, useUncontrolled } from '@mantine/hooks';\nimport {\n  BoxProps,\n  createVarsResolver,\n  ElementProps,\n  factory,\n  Factory,\n  getSize,\n  noop,\n  StylesApiProps,\n  useProps,\n  useResolvedStylesApi,\n  useStyles,\n} from '../../core';\nimport { __BaseInputProps, __InputStylesNames, InputVariant } from '../Input';\nimport { InputBase } from '../InputBase';\nimport { UnstyledButton } from '../UnstyledButton';\nimport classes from './NumberInput.module.css';\nimport { NumberInputChevron } from './NumberInputChevron';\n\n// Re for negative -0, -0., -0.0, -0.00, -0.000 ... strings\n// And for positive 0., 0.0, 0.00, 0.000 ... strings\nconst leadingDecimalZeroPattern = /^(0\\.0*|-0(\\.0*)?)$/;\n\n// Re for 01, 006, 00.02, -0010, -000.293 ... and negative counterparts\nconst leadingZerosPattern = /^-?0\\d+(\\.\\d+)?\\.?$/;\n\n// Re for decimal numbers with trailing zeros like 13.0, 13.00, 5.10 ... strings\nconst trailingZerosPattern = /\\.\\d*0$/;\n\n// Re for numbers with trailing decimal separator like 10. or -3.\nconst trailingDecimalSeparatorPattern = /^-?\\d+\\.$/;\n\nexport interface NumberInputHandlers {\n  increment: () => void;\n  decrement: () => void;\n}\n\nfunction isNumberString(value: unknown) {\n  return typeof value === 'string' && value !== '' && !Number.isNaN(Number(value));\n}\n\nfunction canIncrement(value: number | string) {\n  if (typeof value === 'number') {\n    return value < Number.MAX_SAFE_INTEGER;\n  }\n\n  return value === '' || (isNumberString(value) && Number(value) < Number.MAX_SAFE_INTEGER);\n}\n\nfunction getDecimalPlaces(inputValue: string | number): number {\n  // All digits must be counted, parseFloat precision depends\n  // on the number of digits in the input, not only on the decimal scale\n  return inputValue.toString().replace('.', '').length;\n}\n\nfunction isValidNumber(floatValue: number | undefined, value: string): floatValue is number {\n  return (\n    (typeof floatValue === 'number'\n      ? floatValue < Number.MAX_SAFE_INTEGER\n      : !Number.isNaN(Number(floatValue))) &&\n    !Number.isNaN(floatValue) &&\n    getDecimalPlaces(value) < 14 &&\n    value !== ''\n  );\n}\n\nfunction isInRange(value: number | undefined, min: number | undefined, max: number | undefined) {\n  if (value === undefined) {\n    return true;\n  }\n\n  const minValid = min === undefined || value >= min;\n  const maxValid = max === undefined || value <= max;\n\n  return minValid && maxValid;\n}\n\nexport type NumberInputStylesNames = 'controls' | 'control' | __InputStylesNames;\nexport type NumberInputCssVariables = {\n  controls: '--ni-chevron-size';\n};\n\nexport interface NumberInputProps\n  extends BoxProps,\n    Omit<__BaseInputProps, 'pointer'>,\n    StylesApiProps<NumberInputFactory>,\n    ElementProps<'input', 'size' | 'type' | 'onChange'> {\n  /** Controlled component value */\n  value?: number | string;\n\n  /** Uncontrolled component default value */\n  defaultValue?: number | string;\n\n  /** Called when value changes */\n  onChange?: (value: number | string) => void;\n\n  /** Called when value changes with `react-number-format` payload */\n  onValueChange?: OnValueChange;\n\n  /** Determines whether leading zeros are allowed. If set to `false`, leading zeros are removed when the input value becomes a valid number. @default `true` */\n  allowLeadingZeros?: boolean;\n\n  /** If set, negative values are allowed @default `true` */\n  allowNegative?: boolean;\n\n  /** Characters which when pressed result in a decimal separator @default `['.', ',']` */\n  allowedDecimalSeparators?: string[];\n\n  /** Limits the number of digits that can be entered after the decimal point @default `Infinity` */\n  decimalScale?: number;\n\n  /** Character used as a decimal separator @default `'.'` */\n  decimalSeparator?: string;\n\n  /** If set, 0s are added after `decimalSeparator` to match given `decimalScale`. @default `false` */\n  fixedDecimalScale?: boolean;\n\n  /** Prefix added before the input value */\n  prefix?: string;\n\n  /** Suffix added after the input value */\n  suffix?: string;\n\n  /** Defines the thousand grouping style. */\n  thousandsGroupStyle?: 'thousand' | 'lakh' | 'wan' | 'none';\n\n  /** A function to validate the input value. If this function returns `false`, the `onChange` will not be called and the input value will not change. */\n  isAllowed?: (values: NumberFormatValues) => boolean;\n\n  /** If value is passed as string representation of numbers (unformatted) and number is used in any format props like in prefix or suffix in numeric format and format prop in pattern format then this should be passed as `true`. @default `false` */\n  valueIsNumericString?: boolean;\n\n  /** Controls input `type` attribute @default `'text'` */\n  type?: 'text' | 'tel' | 'password';\n\n  /** A character used to separate thousands */\n  thousandSeparator?: string | boolean;\n\n  /** Minimum possible value */\n  min?: number;\n\n  /** Maximum possible value */\n  max?: number;\n\n  /** Number by which value will be incremented/decremented with up/down controls and keyboard arrows @default `1` */\n  step?: number;\n\n  /** If set, the up/down controls are hidden @default `false` */\n  hideControls?: boolean;\n\n  /** Controls how value is clamped, `strict` – user is not allowed to enter values that are not in `[min, max]` range, `blur` – user is allowed to enter any values, but the value is clamped when the input loses focus (default behavior), `none` – lifts all restrictions, `[min, max]` range is applied only for controls and up/down keys */\n  clampBehavior?: 'strict' | 'blur' | 'none';\n\n  /** If set, decimal values are allowed @default `true` */\n  allowDecimal?: boolean;\n\n  /** Increment/decrement handlers */\n  handlersRef?: React.ForwardedRef<NumberInputHandlers | undefined>;\n\n  /** Value set to the input when increment/decrement buttons are clicked or up/down arrows pressed if the input is empty @default `0` */\n  startValue?: number;\n\n  /** Delay before stepping the value. Can be a number of milliseconds or a function that receives the current step count and returns the delay in milliseconds. */\n  stepHoldInterval?: number | ((stepCount: number) => number);\n\n  /** Initial delay in milliseconds before stepping the value. */\n  stepHoldDelay?: number;\n\n  /** If set, up/down keyboard events increment/decrement value @default `true` */\n  withKeyboardEvents?: boolean;\n\n  /** If set, leading zeros are removed on blur. For example, `00100` -> `100` @default `true` */\n  trimLeadingZeroesOnBlur?: boolean;\n}\n\nexport type NumberInputFactory = Factory<{\n  props: NumberInputProps;\n  ref: HTMLInputElement;\n  stylesNames: NumberInputStylesNames;\n  vars: NumberInputCssVariables;\n  variant: InputVariant;\n}>;\n\nconst defaultProps = {\n  step: 1,\n  clampBehavior: 'blur',\n  allowDecimal: true,\n  allowNegative: true,\n  withKeyboardEvents: true,\n  allowLeadingZeros: true,\n  trimLeadingZeroesOnBlur: true,\n  startValue: 0,\n  allowedDecimalSeparators: ['.', ','],\n} satisfies Partial<NumberInputProps>;\n\nconst varsResolver = createVarsResolver<NumberInputFactory>((_, { size }) => ({\n  controls: {\n    '--ni-chevron-size': getSize(size, 'ni-chevron-size'),\n  },\n}));\n\nfunction clampAndSanitizeInput(sanitizedValue: string | number, max?: number, min?: number) {\n  const stringValue = sanitizedValue.toString();\n  const hasTrailingDecimalSeparator = trailingDecimalSeparatorPattern.test(stringValue);\n\n  const replaced = stringValue.replace(/^0+(?=\\d)/, '');\n  const parsedValue = parseFloat(replaced);\n\n  if (Number.isNaN(parsedValue)) {\n    return replaced;\n  }\n\n  if (parsedValue > Number.MAX_SAFE_INTEGER) {\n    return max !== undefined ? max : replaced;\n  }\n\n  const clamped = clamp(parsedValue, min, max);\n\n  if (hasTrailingDecimalSeparator) {\n    const clampedString = clamped.toString().replace(/^0+(?=\\d)/, '');\n    return `${clampedString}.`;\n  }\n\n  return clamped;\n}\n\nexport const NumberInput = factory<NumberInputFactory>((_props, ref) => {\n  const props = useProps('NumberInput', defaultProps, _props);\n  const {\n    className,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    onChange,\n    onValueChange,\n    value,\n    defaultValue,\n    max,\n    min,\n    step,\n    hideControls,\n    rightSection,\n    isAllowed,\n    clampBehavior,\n    onBlur,\n    allowDecimal,\n    decimalScale,\n    onKeyDown,\n    onKeyDownCapture,\n    handlersRef,\n    startValue,\n    disabled,\n    rightSectionPointerEvents,\n    allowNegative,\n    readOnly,\n    size,\n    rightSectionWidth,\n    stepHoldInterval,\n    stepHoldDelay,\n    allowLeadingZeros,\n    withKeyboardEvents,\n    trimLeadingZeroesOnBlur,\n    allowedDecimalSeparators,\n    attributes,\n    ...others\n  } = props;\n\n  const getStyles = useStyles<NumberInputFactory>({\n    name: 'NumberInput',\n    classes,\n    props,\n    classNames,\n    styles,\n    unstyled,\n    attributes,\n    vars,\n    varsResolver,\n  });\n\n  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi<NumberInputFactory>({\n    classNames,\n    styles,\n    props,\n  });\n\n  const [_value, setValue] = useUncontrolled({\n    value,\n    defaultValue,\n    finalValue: '',\n    onChange,\n  });\n\n  const shouldUseStepInterval = stepHoldDelay !== undefined && stepHoldInterval !== undefined;\n  const inputRef = useRef<HTMLInputElement>(null);\n  const onStepTimeoutRef = useRef<number | null>(null);\n  const stepCountRef = useRef<number>(0);\n\n  const handleValueChange: OnValueChange = (payload, event) => {\n    if (event.source === 'event') {\n      setValue(\n        isValidNumber(payload.floatValue, payload.value) &&\n          !leadingDecimalZeroPattern.test(payload.value) &&\n          !(allowLeadingZeros ? leadingZerosPattern.test(payload.value) : false) &&\n          !trailingZerosPattern.test(payload.value) &&\n          !trailingDecimalSeparatorPattern.test(payload.value)\n          ? payload.floatValue\n          : payload.value\n      );\n    }\n    onValueChange?.(payload, event);\n  };\n\n  const getDecimalPlaces = (inputValue: number | string): number => {\n    const match = String(inputValue).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n    if (!match) {\n      return 0;\n    }\n    return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? +match[2] : 0));\n  };\n\n  const adjustCursor = (position?: number) => {\n    if (inputRef.current && typeof position !== 'undefined') {\n      inputRef.current.setSelectionRange(position, position);\n    }\n  };\n\n  const incrementRef = useRef<() => void>(noop);\n  incrementRef.current = () => {\n    if (!canIncrement(_value)) {\n      return;\n    }\n\n    let val: number;\n    const currentValuePrecision = getDecimalPlaces(_value);\n    const stepPrecision = getDecimalPlaces(step);\n    const maxPrecision = Math.max(currentValuePrecision, stepPrecision);\n    const factor = 10 ** maxPrecision;\n\n    if (!isNumberString(_value) && (typeof _value !== 'number' || Number.isNaN(_value))) {\n      val = clamp(startValue, min, max);\n    } else if (max !== undefined) {\n      const incrementedValue =\n        (Math.round(Number(_value) * factor) + Math.round(step * factor)) / factor;\n      val = incrementedValue <= max ? incrementedValue : max;\n    } else {\n      val = (Math.round(Number(_value) * factor) + Math.round(step * factor)) / factor;\n    }\n\n    const formattedValue = val.toFixed(maxPrecision);\n    setValue(parseFloat(formattedValue));\n    onValueChange?.(\n      { floatValue: parseFloat(formattedValue), formattedValue, value: formattedValue },\n      { source: 'increment' as any }\n    );\n    setTimeout(() => adjustCursor(inputRef.current?.value.length), 0);\n  };\n\n  const decrementRef = useRef<() => void>(noop);\n  decrementRef.current = () => {\n    if (!canIncrement(_value)) {\n      return;\n    }\n\n    let val: number;\n    const minValue = min !== undefined ? min : !allowNegative ? 0 : Number.MIN_SAFE_INTEGER;\n    const currentValuePrecision = getDecimalPlaces(_value);\n    const stepPrecision = getDecimalPlaces(step);\n    const maxPrecision = Math.max(currentValuePrecision, stepPrecision);\n    const factor = 10 ** maxPrecision;\n\n    if ((!isNumberString(_value) && typeof _value !== 'number') || Number.isNaN(_value)) {\n      val = clamp(startValue, minValue, max);\n    } else {\n      const decrementedValue =\n        (Math.round(Number(_value) * factor) - Math.round(step * factor)) / factor;\n      val = minValue !== undefined && decrementedValue < minValue ? minValue : decrementedValue;\n    }\n\n    const formattedValue = val.toFixed(maxPrecision);\n    setValue(parseFloat(formattedValue));\n    onValueChange?.(\n      { floatValue: parseFloat(formattedValue), formattedValue, value: formattedValue },\n      { source: 'decrement' as any }\n    );\n    setTimeout(() => adjustCursor(inputRef.current?.value.length), 0);\n  };\n\n  const handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>) => {\n    onKeyDown?.(event);\n\n    if (readOnly || !withKeyboardEvents) {\n      return;\n    }\n\n    if (event.key === 'ArrowUp') {\n      event.preventDefault();\n      incrementRef.current?.();\n    }\n\n    if (event.key === 'ArrowDown') {\n      event.preventDefault();\n      decrementRef.current?.();\n    }\n  };\n\n  const handleKeyDownCapture = (event: React.KeyboardEvent<HTMLInputElement>) => {\n    onKeyDownCapture?.(event);\n    if (event.key === 'Backspace') {\n      const input = inputRef.current;\n      if (input && input.selectionStart === 0 && input.selectionStart === input.selectionEnd) {\n        event.preventDefault();\n        window.setTimeout(() => adjustCursor(0), 0);\n      }\n    }\n  };\n\n  const handleBlur = (event: React.FocusEvent<HTMLInputElement>) => {\n    let sanitizedValue = _value;\n\n    if (clampBehavior === 'blur' && typeof sanitizedValue === 'number') {\n      sanitizedValue = clamp(sanitizedValue, min, max);\n    }\n\n    if (\n      trimLeadingZeroesOnBlur &&\n      typeof sanitizedValue === 'string' &&\n      getDecimalPlaces(sanitizedValue) < 15\n    ) {\n      sanitizedValue = clampAndSanitizeInput(sanitizedValue, max, min);\n    }\n\n    if (_value !== sanitizedValue) {\n      setValue(sanitizedValue);\n    }\n\n    onBlur?.(event);\n  };\n\n  assignRef(handlersRef, { increment: incrementRef.current, decrement: decrementRef.current });\n\n  const onStepHandleChange = (isIncrement: boolean) => {\n    if (isIncrement) {\n      incrementRef.current?.();\n    } else {\n      decrementRef.current?.();\n    }\n    stepCountRef.current += 1;\n  };\n\n  const onStepLoop = (isIncrement: boolean) => {\n    onStepHandleChange(isIncrement);\n\n    if (shouldUseStepInterval) {\n      const interval =\n        typeof stepHoldInterval === 'number'\n          ? stepHoldInterval\n          : stepHoldInterval(stepCountRef.current);\n      onStepTimeoutRef.current = window.setTimeout(() => onStepLoop(isIncrement), interval);\n    }\n  };\n\n  const onStep = (\n    event: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    isIncrement: boolean\n  ) => {\n    event.preventDefault();\n    inputRef.current?.focus();\n    onStepHandleChange(isIncrement);\n    if (shouldUseStepInterval) {\n      onStepTimeoutRef.current = window.setTimeout(() => onStepLoop(isIncrement), stepHoldDelay);\n    }\n  };\n\n  const onStepDone = () => {\n    if (onStepTimeoutRef.current) {\n      window.clearTimeout(onStepTimeoutRef.current);\n    }\n    onStepTimeoutRef.current = null;\n    stepCountRef.current = 0;\n  };\n\n  const controls = (\n    <div {...getStyles('controls')}>\n      <UnstyledButton\n        {...getStyles('control')}\n        tabIndex={-1}\n        aria-hidden\n        disabled={disabled || (typeof _value === 'number' && max !== undefined && _value >= max)}\n        mod={{ direction: 'up' }}\n        onMouseDown={(event) => event.preventDefault()}\n        onPointerDown={(event) => {\n          onStep(event, true);\n        }}\n        onPointerUp={onStepDone}\n        onPointerLeave={onStepDone}\n      >\n        <NumberInputChevron direction=\"up\" />\n      </UnstyledButton>\n      <UnstyledButton\n        {...getStyles('control')}\n        tabIndex={-1}\n        aria-hidden\n        disabled={disabled || (typeof _value === 'number' && min !== undefined && _value <= min)}\n        mod={{ direction: 'down' }}\n        onMouseDown={(event) => event.preventDefault()}\n        onPointerDown={(event) => {\n          onStep(event, false);\n        }}\n        onPointerUp={onStepDone}\n        onPointerLeave={onStepDone}\n      >\n        <NumberInputChevron direction=\"down\" />\n      </UnstyledButton>\n    </div>\n  );\n\n  return (\n    <InputBase\n      component={NumericFormat}\n      allowNegative={allowNegative}\n      className={cx(classes.root, className)}\n      size={size}\n      inputMode=\"decimal\"\n      {...others}\n      readOnly={readOnly}\n      disabled={disabled}\n      value={_value}\n      getInputRef={useMergedRef(ref, inputRef)}\n      onValueChange={handleValueChange}\n      rightSection={\n        hideControls || readOnly || !canIncrement(_value) ? rightSection : rightSection || controls\n      }\n      classNames={resolvedClassNames}\n      styles={resolvedStyles}\n      unstyled={unstyled}\n      __staticSelector=\"NumberInput\"\n      decimalScale={allowDecimal ? decimalScale : 0}\n      onKeyDown={handleKeyDown}\n      onKeyDownCapture={handleKeyDownCapture}\n      rightSectionPointerEvents={rightSectionPointerEvents ?? (disabled ? 'none' : undefined)}\n      rightSectionWidth={rightSectionWidth ?? `var(--ni-right-section-width-${size || 'sm'})`}\n      allowLeadingZeros={allowLeadingZeros}\n      allowedDecimalSeparators={allowedDecimalSeparators}\n      onBlur={handleBlur}\n      attributes={attributes}\n      isAllowed={(val) => {\n        if (clampBehavior === 'strict') {\n          if (isAllowed) {\n            return isAllowed(val) && isInRange(val.floatValue, min, max);\n          }\n\n          return isInRange(val.floatValue, min, max);\n        }\n\n        return isAllowed ? isAllowed(val) : true;\n      }}\n    />\n  );\n});\n\nNumberInput.classes = { ...InputBase.classes, ...classes };\nNumberInput.displayName = '@mantine/core/NumberInput';\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}